<p>symbol是es6出的一种类型，他也是属于原始类型的范畴(string, number, boolean, null, undefined, symbol)</p>
<h3 class="heading" data-id="heading-0">basic</h3>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'xiaohesong'</span>)
<span class="hljs-keyword">typeof</span> name <span class="hljs-comment">// 'symbol'</span>
<span class="hljs-keyword">let</span> obj = {}
obj[name] = <span class="hljs-string">'xhs'</span>
<span class="hljs-built_in">console</span>.log(obj[name]) <span class="hljs-comment">//xhs</span>
<span class="copy-code-btn">复制代码</span></code></pre><h3 class="heading" data-id="heading-1">symbol for</h3>
<p>这个东西是可共享，在创建的时候会检查全局是否寻在这个key的symbol.如果存在就直接返回这个symbol,如果不存在就会创建，并且在全局注册。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> uid = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"uid"</span>);
<span class="hljs-keyword">let</span> object = {
    [uid]: <span class="hljs-string">"12345"</span>
};

<span class="hljs-built_in">console</span>.log(object[uid]);       <span class="hljs-comment">// "12345"</span>
<span class="hljs-built_in">console</span>.log(uid);               <span class="hljs-comment">// "Symbol(uid)"</span>

<span class="hljs-keyword">let</span> uid2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"uid"</span>);

<span class="hljs-built_in">console</span>.log(uid === uid2);      <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(object[uid2]);      <span class="hljs-comment">// "12345"</span>
<span class="hljs-built_in">console</span>.log(uid2);              <span class="hljs-comment">// "Symbol(uid)"</span>
<span class="copy-code-btn">复制代码</span></code></pre><blockquote>
<p>此处所说的共享是全局性的共享，类似于global scope，是整个大环境下的共享.</p>
</blockquote>
<h3 class="heading" data-id="heading-2">symbol keyfor</h3>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> uid = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"uid"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(uid));    <span class="hljs-comment">// "uid"</span>

<span class="hljs-keyword">let</span> uid2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"uid"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(uid2));   <span class="hljs-comment">// "uid"</span>

<span class="hljs-keyword">let</span> uid3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"uid"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(uid3));   <span class="hljs-comment">// undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>全局注册表不存在uid3这个共享的symbol.所以取不出对应的key.由此可见，这个是获取对应的key.</p>
<h3 class="heading" data-id="heading-3">symbol 不可强制转换</h3>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> uid = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'uid'</span>)
uid + <span class="hljs-string">''</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这里会报错，根据规范，他会把uid转换成字符串进行相加。如果真的相加，可以先<code>String(uid)</code>之后再相加，不过目前看来，似乎没什么意义。</p>
<h3 class="heading" data-id="heading-4">obj中symbol key的获取</h3>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> uid = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'uid'</span>)
<span class="hljs-keyword">let</span> obj = {
    [uid]: <span class="hljs-string">'uid'</span>
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj)) <span class="hljs-comment">// []</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)) <span class="hljs-comment">// []</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj)) <span class="hljs-comment">// [Symbol(uid)]</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>es6针对这个，添加了<code>Object.getOwnPropertySymbols</code>方法。</p>
<p>是不是感觉很少用到Symbols.其实es6内部用的还是不少的。</p>
<h3 class="heading" data-id="heading-5">Symbol.hasInstance</h3>
<p>每个函数都有这个方法。或许你对这个方法不是很熟，他其实就是<code>instanceof</code>所做的事情。
没错，es6给你重写了这个方法。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Xiao</span>(<span class="hljs-params"></span>)</span>{}
<span class="hljs-keyword">const</span> xiao = <span class="hljs-keyword">new</span> Xiao
xiao <span class="hljs-keyword">instanceof</span> Xiao <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>实际上es6帮你那么干了</p>
<pre><code class="hljs javascript copyable" lang="javascript">Xiao[<span class="hljs-built_in">Symbol</span>.hasInstance](xiao)
<span class="copy-code-btn">复制代码</span></code></pre><p>这个是内部的方法，不支持重写，当然，我们可以在原型上改写。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-built_in">Object</span>.definePrototype(Xiao, <span class="hljs-built_in">Symbol</span>.hasInstance, {
   <span class="hljs-attr">value</span>: (v) : <span class="hljs-built_in">Boolean</span>(v)
})
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> Xiao
x <span class="hljs-keyword">instanceof</span> Xiao <span class="hljs-comment">//true</span>
<span class="hljs-number">0</span> <span class="hljs-keyword">instanceof</span> Xiao <span class="hljs-comment">//false</span>
<span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> Xiao <span class="hljs-comment">//true</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>可以发现，我们改写他返回对应的是否为boolean类型。</p>
<h3 class="heading" data-id="heading-6">Symbol.isConcatSpreadable</h3>
<p>这个和其他的一些属性不同，他是默认不存在一些标准对象上。简单的使用</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> objs = {<span class="hljs-number">0</span>: <span class="hljs-string">'first'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'second'</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, [<span class="hljs-built_in">Symbol</span>.isConcatSpreadable]: <span class="hljs-literal">true</span>}
[<span class="hljs-string">'arrs'</span>].concat(objs) <span class="hljs-comment">//["arrs", "first", "second"]</span>
<span class="copy-code-btn">复制代码</span></code></pre><h3 class="heading" data-id="heading-7">Symbol.toPrimitive</h3>
<p>这个用的就多了，进行类型转换的时候，对象会进行尝试转换成原始类型，就是通过<code>toPrimitive</code>.这个方法，标准类型的原型上都存在。</p>
<p>进行类型转换的时候，<code>toPrimitive</code>会被强制的调用一个参数，在规范中这个参数被称之为<code>hint</code>. 这个参数是三个值('number', 'string', 'default')其中的一个。</p>
<p>顾名思义，<code>string</code>返回的是<code>string</code>, <code>number</code>返回的是<code>number</code>，<code>default</code>是没有特别指定，默认。</p>
<p>那么什么是默认的情况呢？ 大多数的情况下，默认情况就是数字模式。(日期除外，他的默认情况视为字符串模式)</p>
<p>其实在类型转换时调用默认情况的也不是很多。如(<code>==</code>, <code>+</code>)或者将参数传递给<code>Date</code>的构造参数的时候。</p>
<ul>
<li>
<p>number mode
在数字情况下的行为(优先级从高到低)</p>
<ul>
<li>首先调用<code>valueOf</code>，如果是一个原始类型，那就返回。</li>
<li>如果前面不是原始值，那么就尝试调用<code>toString</code>，如果是原始值，那么就返回</li>
<li>如果都不存在，那么就报错</li>
</ul>
</li>
<li>
<p>string mode
在字符串的情况下，行为略有不同(优先级从高到低)</p>
<ul>
<li>首先调用<code>toString</code>，如果是原始值，那么就返回</li>
<li>如果前面不是原始值，那么就尝试调用<code>valueOf</code>，如果是原始值，那么就返回</li>
<li>抛出错误</li>
</ul>
</li>
</ul>
<p>嗯，是不是感觉挺绕的，是啊，代码阐述下嘛。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'valueOf'</span>)},
    <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span>)}
}
<span class="hljs-comment">// console.log value is</span>
obj + <span class="hljs-number">2</span> <span class="hljs-comment">//valueOf</span>
obj == <span class="hljs-number">2</span> <span class="hljs-comment">// valueOf</span>
<span class="hljs-built_in">Number</span>(obj) <span class="hljs-comment">// valueOf</span>
<span class="hljs-built_in">String</span>(obj) <span class="hljs-comment">// toString</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>通过上面的输出，可以发现大多数的情况都是首先调用<code>valueOf</code>.
包括默认的情况，他的默认是调用的数字模式，而且绝大数都是调用的数字模式，可以发现<code>toString</code>是调用了<code>string</code>的模式。所以你可以认为，基本就是数字模式，除非很显示的是字符串模式。</p>
<p>对于这个调用的模式还不是很清楚？没事，es6把这个内部的方法对外暴露出来了，我们可以改写他，输出这个<code>hint</code>的类型。 来</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Temperature</span>(<span class="hljs-params">degrees</span>) </span>{
    <span class="hljs-keyword">this</span>.degrees = degrees;
}

Temperature.prototype[<span class="hljs-built_in">Symbol</span>.toPrimitive] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) </span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hint is'</span>, hint)
};

<span class="hljs-keyword">let</span> freezing = <span class="hljs-keyword">new</span> Temperature(<span class="hljs-number">32</span>);

freezing + <span class="hljs-number">2</span> <span class="hljs-comment">// ..</span>
freezing / <span class="hljs-number">2</span> <span class="hljs-comment">// ..</span>
...
<span class="copy-code-btn">复制代码</span></code></pre><p>上面的类型，你可以试试。</p>
<h3 class="heading" data-id="heading-8">Symbo.species</h3>
<p>这个需要联系<code>class</code>的上下文来阐述了，<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fxiaohesong.gitbook.io%2Ftoday-i-learn%2Ffront-end%2Fes6%2Funderstanding-es6%2Fclass%23symbolspecies-shu-xing" rel="nofollow noopener noreferrer">点击此处</a>查看详细</p>
<h3 class="heading" data-id="heading-9">Symbol.iterator</h3>
<p>这个在也有详细的记载，可赋予一些能力。详情请<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxiaohesong%2Ftil%2Fblob%2Fmaster%2Ffront-end%2Fjavascript%2Fobjects%2Fiterator.md" rel="nofollow noopener noreferrer">前往此处</a></p>
<p>本文<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fxiaohesong.gitbook.io%2Ftoday-i-learn%2Ffront-end%2Fes6%2Funderstanding-es6%2Fsymbol" rel="nofollow noopener noreferrer">原文在此处</a>, <strong>推荐一个高质量<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.rails365.net%2F" rel="nofollow noopener noreferrer">教学视频网站</a>, 很多免费的视频及资源</strong></p>
